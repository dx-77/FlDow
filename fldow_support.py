#!/usr/bin/env python
#
#This file is part of FlDow project
#Copyright (C) 2018 dx-77 <d.x77@yandex.ru>. 
#GitHub : https://github.com/dx-77
#
#This program is free software: you can redistribute it and/or modify it under the terms
#of the GNU General Public License as published by the Free Software Foundation,
#either version 3 of the License, or (at your option) any later version.
#This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
#without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#See the GNU General Public License for more details.
# 
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Support module generated by PAGE version 4.9
# In conjunction with Tcl version 8.6

import os
import sys
import time
import tkinter.messagebox
import _thread
import urllib.request
from consts import *

try:
    from Tkinter import *
except ImportError:
    from tkinter import *

try:
    import ttk
    py3 = 0
except ImportError:
    import tkinter.ttk as ttk
    py3 = 1


class AppURLopener(urllib.request.FancyURLopener):
    version = list(USERAGENT.values())[0]
    
urllib._urlopener = AppURLopener()
    

def btnselect():
    global wgui
    def showlist(delay=4):
        if wgui.slb['selectmode'] == EXTENDED:
            wgui.slb.delete(0, END)
            for tool in toolslist:
                wgui.slb.insert(END, tool)
            for tool in selected_toolslist:
                k = toolslist.index(tool)
                wgui.slb.selection_set(k)
            wgui.btnselect.config(state=DISABLED)
            wgui.btndownload.config(state=NORMAL)
        else:
            wgui.slb.config(selectmode=EXTENDED)
            wgui.btndownload.config(state=DISABLED)
            wgui.slb.delete(0, END)
            wgui.slb.insert(END, prgtext['useselectkeys'][lang])
            wgui.slb.insert(END, prgtext['appearingsoon'][lang])
            wgui.slb.after(int(delay*1000), showlist)
        
    if wgui.slb['selectmode'] == SINGLE:
        showlist()
  
def downloadprogress(count, blocksize, totalsize):
    '''Reporthook func of urllib.request.urlretrieve'''
    global percent
    percent = int(count*blocksize*100/totalsize)

def urlextract(url, str1, str2, charset='utf-8'):
    url = urllib.request.urlopen(url).read().decode(charset)
    url = url[url.find(str1) + len(str1):url.find(str2)]
    return url

def changeurl(url, tool_index, x64=False):
    if selected_toolslist[tool_index] not in tools_nondirect_URL:
        return url
    
    if selected_toolslist[tool_index] == '360TS':
        url = 'https:' + urlextract(url, '<a class="download-link" href="',
                                    '">перезапустите ее</a>')
            
    elif selected_toolslist[tool_index] == '7-Zip':
        url = urlextract(url, '<TD class="Item" align="center"><A href="',
                         '.exe">Download</A></TD>')
        url = 'http://www.7-zip.org/' + url + '.exe'
        if x64: url = url.replace('.exe', '-x64') + '.exe'
            
    elif selected_toolslist[tool_index] == 'Adwcleaner':
        url = urlextract(url, '<a id="downloadLink" href="', '">Click here!</a>')
        
    elif selected_toolslist[tool_index] == 'AIMP':
        url = urlextract(url, 'Скачать с сервера:</b><br/><ul><li><a href="', '">AIMP.RU</a>')
            
    elif selected_toolslist[tool_index] == 'CCleaner':
        url = urlextract(url, 'active short download-button" href="', '" onclick="_gaq.push')
        url = urlextract(url, '<a href="/download/file',
                         '" class="text" style="text-decoration: none;" id="download-link">')
        url = 'https://filehippo.com/download/file' + url
            
    elif selected_toolslist[tool_index] == 'CPU-Z':
        url = 'https://www.cpuid.com' + urlextract(
            url, '<a class="button icon-zip" href="',
            '"><span>zip • english <em>'
        )
        str1 = str(
            'is ready for download.\n                            </p>\n               '
            '             <p>\n                                <a class="button" href="'
        )
        url = urlextract(url, str1, '"><span>DOWNLOAD NOW!</span></a>')
            
    elif selected_toolslist[tool_index] == 'CrystalDiskMark':
        url = 'https://osdn.net' + urlextract(url, 'pref-download-btn-win32" href="',
                                              '" title="Windows"')
        url = 'https://osdn.net' + urlextract(
            url, '<a class="mirror_link" target="_brank" rel="nofollow" href="',
                   'zip">CrystalDiskMark'
        ) + 'zip'
                            
    elif selected_toolslist[tool_index] == 'GIMP':
         url = urlextract(
            url, '<span class=\'win-button\'>\n            <a\n            href="', '.exe"'
         )
         url = 'https:' + url + '.exe'
            
    elif selected_toolslist[tool_index] == 'GPU-Z':
        s = urlextract(
            url, '<input type="hidden" name="id" value="',
            '" />\n\t\t\t\t<input type="submit" class="button startbutton" value="Download"'
        )
        dt = 'id=' + s + '&server_id=6'
        url = urllib.request.urlopen(url, data=dt.encode()).geturl()
        
    elif selected_toolslist[tool_index] == 'HWMonitor':
        url = urlextract(url, '<a class="button icon-zip" href="',
                         '"><span>zip • english <em>')
        url = urlextract(url, '<a class="button" href="', '"><span>DOWNLOAD NOW!')
        
    elif selected_toolslist[tool_index] == 'Inkscape':
        if x64:
            url = urllib.request.urlopen(url).read().decode('utf-8')
            str1 = '">installer (exe)</a></li>'
            url = url[url.find(str1) + len(str1):]
            str1 = str(
                '<strong>64-bit Windows</strong>:</p>\n\n\t\t\t<ul>\n\t\t\t\t<li><a href="'
            )
            str2 = '">installer (exe)</a></li>'
            url = url[url.find(str1) + len(str1):url.find(str2)]
        else:
            url = urlextract(
                url,
                '<strong>32-bit Windows</strong>:</p>\n\n\t\t\t<ul>\n\t\t\t\t'
                '<li class="clearfix"><a href="', '">installer (exe)</a></li>'
            )
           
    elif selected_toolslist[tool_index] == 'K-Lite':
        url = urlextract(url, 'HTTP</td><td><a href="', '">Mirror 1</a>')
            
    elif selected_toolslist[tool_index] == 'MBAM':
        url = urlextract(url, 'downloadUrl = "', '/";\n      setTimeout(function()')
            
    elif selected_toolslist[tool_index] == 'Notepad++':
        url = urlextract(url, 'Download 32-bit x86</h2>\r\n<ul>\r\n<li><strong><a href="',
                         '"><img title="Notepad++ Download"')
        url = 'https://notepad-plus-plus.org' + url
        if x64: url = url.replace('.exe', '.x64') + '.exe'
        
    elif selected_toolslist[tool_index] == 'OCCT':
        url = urlextract(url, 'If your download does not start, <a href="',
                         '"> click here </a>')
        url = 'http://www.ocbase.com/' + url
            
    elif selected_toolslist[tool_index] == 'PartitionWizard':
        url = urllib.request.Request(url, headers=USERAGENT)
        url = urlextract(url, '<p><a href="', '" data-down="free"')
                           
    elif selected_toolslist[tool_index] == 'UVS':
         url = 'http://dsrt.dyndns.org/files/uvs_v' + \
                urlextract(url, '<a href="/files/uvs_v', '">uVS</a>', charset='windows-1251')
            
    elif selected_toolslist[tool_index] == 'VLC':
        url = 'https:' + urlextract(url, 'btn-dl"'+" href='", ".exe'>") + '.exe'
        if x64: url = url.replace('32', '64')
            
    elif selected_toolslist[tool_index] == 'WinBox':
        url = 'https:' + urlextract(url, '<table class="utils"><tr><td><a href="',
                                    '">Winbox version')
                
    return url
    
def detectext(nm, url=None):
    if url:
        try:
            r = urllib.request.urlopen(url)
        except:
            return '.exe'
        b = r.read(2)
    else:
        with open(nm,'rb') as f:
            b = f.read(2)
    if b == b'MZ':
        return '.exe'
    elif b == b'\xd0\xcf':
        return '.msi'
    else:
        return '.zip'
 
def downloadtool(downfiles_limit):
    '''Thread download func to download tools in selected_toolslist using URL in toolsdict'''
    global downflag, completeflag
    while tool_index < len(selected_toolslist):
        try:
            if downflag[tool_index]: continue
            
            nm = './Tools/%s/%s' % (selected_toolslist[tool_index],
                                    selected_toolslist[tool_index])
            url = changeurl(toolsdict[selected_toolslist[tool_index]][0], tool_index)
            ext = detectext(nm, url)
            t = 111
            if os.access(nm + ext, os.W_OK):
                t = (time.time() - os.path.getmtime(nm + ext)) / 3600
                if t > HOURS_TO_RENEW:
                    try:
                        os.remove(nm + ext)
                    except:
                        pass
            if t > HOURS_TO_RENEW:
                try:
                    urllib.request.urlretrieve(url, nm, reporthook=downloadprogress)
                except:
                    urllib._urlopener.retrieve(url, nm, reporthook=downloadprogress)
                try:
                    os.rename(nm, nm + detectext(nm))
                except:
                    pass
                
            if toolsdict[selected_toolslist[tool_index]][1]:
                nm = './Tools/%s/%s_x64' % (selected_toolslist[tool_index],
                                            selected_toolslist[tool_index])
                url = changeurl(
                    toolsdict[selected_toolslist[tool_index]][1], tool_index, x64=True
                )
                ext = detectext(nm, url)
                t = 222
                if os.access(nm + ext, os.W_OK):
                    t = (time.time() - os.path.getmtime(nm + ext)) / 3600
                    if t > HOURS_TO_RENEW:
                        try:
                            os.remove(nm + ext)
                        except:
                            pass
                if t > HOURS_TO_RENEW:
                    try:
                        urllib.request.urlretrieve(url, nm, reporthook=downloadprogress)
                    except:
                        urllib._urlopener.retrieve(url, nm, reporthook=downloadprogress)
                    try:
                        os.rename(nm, nm + detectext(nm))
                    except:
                        pass
                    
            downflag[tool_index] = True
        except IndexError:
            break
        except:
            downflag[tool_index] = 'Error'
        if tool_index == downfiles_limit: break
    completeflag = True

def downstatus():
    '''Callback func which monitoring status of urlretrieve'''
    global wgui, tool_index, percent
    if (wgui.btndownload['state'] == DISABLED) and (tool_index < len(selected_toolslist)):
        try:
            if wgui.slb.get(END) != prgtext['downloading'][lang] + \
            ' %s...' % selected_toolslist[tool_index]:
                wgui.slb.insert(
                    END, prgtext['downloading'][lang] + ' %s...' % selected_toolslist[tool_index]
                )
                wgui.slb.see(END)
            if downflag[tool_index] == 'Error': 
                raise urllib.request.URLError(11001)
            if downflag[tool_index]:
                percent = 0
                wgui.prb['value'] = percent
                wgui.slb.insert(
                    END,
                    prgtext['download'][lang] + ' ' +selected_toolslist[tool_index]+ ' ' +
                    prgtext['complete'][lang]
                )
                wgui.slb.see(END)
                tool_index += 1
        except: 
            percent = 0
            wgui.prb['value'] = percent
            wgui.slb.insert(
                END, prgtext['errordownloading'][lang] + ' %s' % selected_toolslist[tool_index]
            )
            wgui.slb.see(END)
            tool_index += 1
        wgui.slb.update_idletasks()
        wgui.slb.after(500, downstatus)
        
    if completeflag:
        wgui.btndownload.config(state=NORMAL)
        wgui.btnselect.config(state=NORMAL)
        if wgui.slb.get(END) != prgtext['allcomplete'][lang]:
            wgui.slb.insert(END, prgtext['allcomplete'][lang])
            wgui.slb.see(END)
        
def startprogress():
    global wgui
    if not completeflag:
        wgui.prb['value'] = percent
        wgui.prb.after(100, startprogress)
        
def btndownload():
    global wgui, downflag, tool_index, completeflag, percent, selected_toolslist
           
    if wgui.btnselect['state'] == DISABLED:
        wgui.slb.config(selectmode=SINGLE)
        wgui.btnselect.config(state=NORMAL)
        cs = wgui.slb.curselection()
        wgui.slb.delete(0, END)
        if not cs:
            wgui.slb.insert(END, prgtext['nothingdownload'][lang])
            wgui.slb.insert(END, prgtext['selectdownload'][lang])
            wgui.btndownload.config(state=DISABLED)
        selected_toolslist = [toolslist[tool_index] for tool_index in cs]
    
    if not selected_toolslist:
        return False
       
    try:
        if not os.access('./Tools', os.F_OK): os.mkdir('./Tools')
    except:
        tkinter.messagebox.showerror(prgtext['error'][lang],
                                     prgtext['foldererror'][lang] + ' "Tools"')
        return False
        
    for tool in selected_toolslist:
        path = './Tools/%s' % tool
        try:
            if not os.access(path, os.F_OK): os.mkdir(path)
        except:
            tkinter.messagebox.showerror(prgtext['error'][lang],
                                         prgtext['foldererror'][lang] + ' "%s"' % path)
            return False
    
    wgui.slb.insert(END, prgtext['tryingdownload'][lang] + ':')
    wgui.slb.insert(END, selected_toolslist)
    wgui.slb.insert(END, prgtext['filessaved'][lang] + ' %s/Tools' % os.path.abspath(os.curdir))
    wgui.btndownload.config(state=DISABLED)
    wgui.btnselect.config(state=DISABLED)
    wgui.btndownload.update()
    completeflag = False
    downflag = [False]*len(selected_toolslist)
    tool_index, percent = 0, 0
    downstatus()
    _thread.start_new_thread(downloadtool, (MAX_DOWN_FILES,))
    startprogress()
    
    return True
    
def btnquit():
    if wgui.btndownload['state'] == DISABLED and wgui.btnselect['state'] == DISABLED:
        if tkinter.messagebox.askyesno(prgtext['attention'][lang],
                                       prgtext['downloadprogress'][lang] + ' ?'):
            destroy_window()
    else:
        destroy_window()

def mnabout():
    tkinter.messagebox.showinfo(prgtext['mabout'][lang] + '...', PROGRAMVER)

def mnf1():
    tkinter.messagebox.showinfo(prgtext['mf1'][lang], prgtext['f1text'][lang])

def mnexit():
    btnquit()

def init(top, gui, *args, **kwargs):
    global wgui, top_level, root
    wgui = gui
    top_level = top
    root = top

def destroy_window():
    # Function which closes the window.
    global top_level
    top_level.destroy()
    top_level = None

if __name__ == '__main__':
    import fldow
    fldow.vp_start_gui()